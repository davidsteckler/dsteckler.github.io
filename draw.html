<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactive Whiteboard</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box }
    body { font-family:'Segoe UI',sans-serif; background:#f5f5f5; overflow:hidden }
    .container { display:flex; flex-direction:column; height:100vh }
    .toolbar { display:flex; flex-wrap:wrap; padding:10px; background:#333; gap:5px; }
    .toolbar-section { display:flex; gap:5px; align-items:center }
    .board-container { position:relative; flex:1; background:#fff; overflow:hidden }
    canvas { position:absolute; top:0; left:0; border:1px solid #ddd; cursor:crosshair }
    button { padding:8px 12px; border:none; background:#555; color:#fff; border-radius:4px; cursor:pointer }
    button.active { background:#4CAF50 }
    input[type=color] { width:40px; height:30px; border:none; cursor:pointer }
    input[type=range] { width:100px }
    input[type=text] { width:70px; padding:4px; border:1px solid #ccc; border-radius:4px }
    #text-input { position:absolute; display:none; border:1px dashed #000; background:transparent; resize:none }
    #notification { position:fixed; top:60px; right:10px; background:rgba(0,0,0,0.7); color:#fff; padding:10px; border-radius:5px; opacity:0; transition:opacity .5s }
    #status-bar { display:flex; justify-content:space-between; background:#333; color:#fff; padding:5px 10px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="toolbar">
      <div class="toolbar-section">
        <button id="pencil" class="tool active">✏️</button>
        <button id="brush" class="tool">🖌️</button>
        <button id="eraser" class="tool">🧽</button>
        <button id="line" class="tool">📏</button>
        <button id="rect" class="tool">◻️</button>
        <button id="circle" class="tool">⭕</button>
        <button id="text" class="tool">T</button>
        <button id="select" class="tool">🔍</button>
      </div>
      <div class="toolbar-section">
        <input type="color" id="color-picker" value="#000000" title="Pick a color…">
        <input type="text" id="hex-input" placeholder="#rrggbb" title="Or type any hex">
        <div class="color-preset selected-color" style="background:#000" data-color="#000"></div>
        <div class="color-preset" style="background:#f00" data-color="#f00"></div>
        <div class="color-preset" style="background:#00f" data-color="#00f"></div>
      </div>
      <div class="toolbar-section">
        <span>Size:</span>
        <input type="range" id="size-slider" min="1" max="50" value="3">
      </div>
      <div class="toolbar-section">
        <button id="undo">↩️</button>
        <button id="redo">↪️</button>
        <button id="clear">🗑️</button>
        <button id="save">💾</button>
        <button id="grid-toggle">🔳</button>
      </div>
    </div>
    <div class="board-container" id="board-container">
      <canvas id="main-canvas"></canvas>
      <canvas id="grid-overlay" style="display:none"></canvas>
      <textarea id="text-input"></textarea>
    </div>
    <div id="status-bar">
      <div id="tool-status">Tool: Pencil</div>
      <div id="canvas-position">0, 0</div>
    </div>
  </div>
  <div id="notification"></div>

  <script>
  document.addEventListener('DOMContentLoaded', ()=> {
    const board = document.getElementById('board-container');
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const grid = document.getElementById('grid-overlay');
    const gctx = grid.getContext('2d');
    const notif = document.getElementById('notification');
    const textInput = document.getElementById('text-input');
    const cp = document.getElementById('color-picker');
    const hex = document.getElementById('hex-input');
    const presets = document.querySelectorAll('.color-preset');

    let w,h;
    let tool='pencil', color='#000000', size=3;
    let isDrawing=false, points=[], startX, startY;
    let shapes=[], history=[], step=-1;
    let showGrid=false;

    function resize() {
      w=board.clientWidth; h=board.clientHeight;
      canvas.width=w; canvas.height=h;
      grid.width=w; grid.height=h;
      redraw(); if (showGrid) drawGrid();
    }
    window.addEventListener('resize', resize);
    resize();

    // ─── TOOLBAR ───────────────────────────────────
    document.querySelectorAll('.tool').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        document.querySelectorAll('.tool').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        tool = btn.id;
        document.getElementById('tool-status').textContent = 'Tool: '+btn.textContent;
        if (textInput.style.display==='block') finalizeText();
      });
    });
    cp.addEventListener('input', e=>{
      color=e.target.value;
      hex.value=color;
      presets.forEach(p=>p.classList.remove('selected-color'));
    });
    hex.addEventListener('input', e=>{
      const v=e.target.value;
      if (/^#([0-9A-Fa-f]{6})$/.test(v)) {
        color=v; cp.value=v;
        presets.forEach(p=>p.classList.remove('selected-color'));
      }
    });
    presets.forEach(p=>{
      p.addEventListener('click', ()=>{
        color=p.dataset.color;
        cp.value=color; hex.value=color;
        presets.forEach(x=>x.classList.remove('selected-color'));
        p.classList.add('selected-color');
      });
    });
    document.getElementById('size-slider').addEventListener('input', e=> size=+e.target.value);
    document.getElementById('grid-toggle').addEventListener('click', ()=>{
      showGrid = !showGrid;
      grid.style.display = showGrid?'block':'none';
      if (showGrid) drawGrid();
    });
    document.getElementById('clear').addEventListener('click', ()=>{
      if (!confirm('Clear board?')) return;
      shapes=[]; saveHistory(); redraw(); notify('Cleared');
    });
    document.getElementById('undo').addEventListener('click', undo);
    document.getElementById('redo').addEventListener('click', redo);
    document.getElementById('save').addEventListener('click', saveImage);

    // ─── DRAW HANDLERS ─────────────────────────────
    canvas.addEventListener('mousedown', e=>{
      isDrawing=true;
      const r=canvas.getBoundingClientRect();
      startX = e.clientX - r.left;
      startY = e.clientY - r.top;
      points = [{x:startX,y:startY}];
      if (tool==='text') {
        textInput.style.display='block';
        textInput.style.left=`${startX}px`;
        textInput.style.top=`${startY}px`;
        textInput.style.color=color;
        textInput.style.fontSize=`${size*5}px`;
        textInput.value='';
        textInput.focus();
      } else {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }
    });
    canvas.addEventListener('mousemove', e=>{
      const pos = canvas.getBoundingClientRect();
      const x = e.clientX-pos.left|0, y = e.clientY-pos.top|0;
      document.getElementById('canvas-position').textContent = x+', '+y;
      if (!isDrawing || tool==='text') return;
      if (tool==='pencil' || tool==='brush' || tool==='eraser') {
        const px = tool==='eraser' ? '#fff' : color;
        points.push({x,y});
        ctx.strokeStyle = px;
        ctx.lineWidth = size * (tool==='brush'?2:1);
        ctx.globalAlpha = 1;         // ← full opacity
        ctx.lineTo(x,y);
        ctx.stroke();
        return;
      }
      // preview shapes
      redraw(); 
      ctx.strokeStyle=color; ctx.lineWidth=size; ctx.globalAlpha=1;
      if (tool==='line') {
        ctx.beginPath(); ctx.moveTo(startX,startY);
        ctx.lineTo(x,y); ctx.stroke();
      }
      if (tool==='rect') {
        const w = x-startX, h = y-startY;
        ctx.strokeRect(startX, startY, w, h);
      }
      if (tool==='circle') {
        const r = Math.hypot(x-startX, y-startY);
        ctx.beginPath(); ctx.arc(startX, startY, r, 0,Math.PI*2);
        ctx.stroke();
      }
    });
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseout', endDraw);

    function endDraw() {
      if (!isDrawing) return; isDrawing=false;
      if (tool==='text') return;
      // commit
      if (tool==='pencil' || tool==='brush' || tool==='eraser') {
        shapes.push({type:'path', pts:points, color:(tool==='eraser'? '#fff':color), size:size*(tool==='brush'?2:1)});
      }
      if (tool==='line') shapes.push({type:'line', x1:startX,y1:startY, x2:points.slice(-1)[0].x, y2:points.slice(-1)[0].y, color, size});
      if (tool==='rect') shapes.push({type:'rect', x:startX,y:startY, w:points.slice(-1)[0].x-startX, h:points.slice(-1)[0].y-startY, color, size});
      if (tool==='circle') {
        const last=points.slice(-1)[0];
        const r = Math.hypot(last.x-startX, last.y-startY);
        shapes.push({type:'circle', x:startX,y:startY,r, color,size});
      }
      saveHistory();
      redraw();
    }

    function redraw() {
      ctx.clearRect(0,0,w,h);
      shapes.forEach(s=>{
        ctx.globalAlpha=1;
        ctx.strokeStyle=s.color; ctx.lineWidth=s.size;
        if (s.type==='path') {
          ctx.beginPath();
          ctx.moveTo(s.pts[0].x,s.pts[0].y);
          s.pts.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
          ctx.stroke();
        }
        if (s.type==='line') {
          ctx.beginPath();
          ctx.moveTo(s.x1,s.y1);
          ctx.lineTo(s.x2,s.y2);
          ctx.stroke();
        }
        if (s.type==='rect') {
          ctx.strokeRect(s.x,s.y,s.w,s.h);
        }
        if (s.type==='circle') {
          ctx.beginPath();
          ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
          ctx.stroke();
        }
        if (s.type==='text') {
          ctx.fillStyle=s.color;
          ctx.font=`${s.size*5}px sans-serif`;
          ctx.fillText(s.text,s.x,s.y);
        }
      });
    }

    // ─── TEXT FINALIZE ─────────────────────────────
    function finalizeText() {
      if (textInput.value.trim()) {
        shapes.push({
          type:'text',
          x:parseInt(textInput.style.left),
          y:parseInt(textInput.style.top),
          text:textInput.value,
          color,
          size
        });
        saveHistory();
        redraw();
      }
      textInput.style.display='none';
    }
    textInput.addEventListener('blur', finalizeText);

    // ─── GRID ───────────────────────────────────────
    function drawGrid() {
      gctx.clearRect(0,0,w,h);
      gctx.strokeStyle='#ddd'; gctx.lineWidth=.5;
      const gap = 20;
      for (let x=0;x<=w;x+=gap){
        gctx.beginPath();
        gctx.moveTo(x,0); gctx.lineTo(x,h); gctx.stroke();
      }
      for (let y=0;y<=h;y+=gap){
        gctx.beginPath();
        gctx.moveTo(0,y); gctx.lineTo(w,y); gctx.stroke();
      }
    }

    // ─── HISTORY ────────────────────────────────────
    function saveHistory(){
      if (step < history.length-1) history = history.slice(0, step+1);
      history.push(JSON.stringify(shapes));
      step++;
      if (history.length>50) { history.shift(); step--; }
    }
    function undo(){
      if (step>0) {
        step--;
        shapes = JSON.parse(history[step]);
        redraw();
        notify('Undo');
      } else notify('No more undo');
    }
    function redo(){
      if (step < history.length-1) {
        step++;
        shapes = JSON.parse(history[step]);
        redraw();
        notify('Redo');
      } else notify('No more redo');
    }

    // ─── SAVE IMAGE ─────────────────────────────────
    function saveImage(){
      const link=document.createElement('a');
      link.download = 'whiteboard.png';
      link.href = canvas.toDataURL();
      link.click();
      notify('Saved image');
    }

    // ─── UTILITIES ──────────────────────────────────
    function notify(msg){
      notif.textContent = msg;
      notif.style.opacity = 1;
      setTimeout(()=> notif.style.opacity=0, 1500);
    }
  });
  </script>
</body>
</html>
